
@inproceedings{gillShortCutDeforestation1993,
	location = {New York, {NY}, {USA}},
	title = {A short cut to deforestation},
	isbn = {978-0-89791-595-3},
	url = {https://dl.acm.org/doi/10.1145/165180.165214},
	doi = {10.1145/165180.165214},
	series = {{FPCA} '93},
	pages = {223--232},
	booktitle = {Proceedings of the conference on Functional programming languages and computer architecture},
	publisher = {Association for Computing Machinery},
	author = {Gill, Andrew and Launchbury, John and Peyton Jones, Simon L.},
	urldate = {2024-09-29},
	date = {1993-07-01},
	file = {Full Text PDF:/home/wowaster/Zotero/storage/MWW7IN3D/Gill et al. - 1993 - A short cut to deforestation.pdf:application/pdf},
}

@inproceedings{peytonjonesPlayingRulesRewriting2001,
	location = {Firenze, Italy},
	title = {Playing by the Rules: Rewriting as a practical optimisation technique in {GHC}},
	pages = {209--239},
	booktitle = {Proceedings of the 2001 {ACM} {SIGPLAN} Haskell Workshop ({HW}’2001)},
	author = {Peyton Jones, Simon and Tolmach, Andrew and Hoare, Tony},
	date = {2001-09-02},
	file = {PDF:/home/wowaster/Zotero/storage/HKYKF954/Peyton Jones et al. - 2001 - Playing by the Rules Rewriting as a practical optimisation technique in GHC.pdf:application/pdf},
}

@inproceedings{wadlerTheoremsFree1989,
	location = {Imperial College, London, United Kingdom},
	title = {Theorems for free!},
	isbn = {978-0-89791-328-7},
	url = {http://portal.acm.org/citation.cfm?doid=99370.99404},
	doi = {10.1145/99370.99404},
	abstract = {From the type of a polymorphic function we can derive a theorem that it satisfies. Every function of the same type satisfies the same theorem. This provides a free source of useful theorems, courtesy of Reynolds’ abstraction theorem for the polymorphic lambda calculus.},
	eventtitle = {the fourth international conference},
	pages = {347--359},
	booktitle = {Proceedings of the fourth international conference on Functional programming languages and computer architecture  - {FPCA} '89},
	publisher = {{ACM} Press},
	author = {Wadler, Philip},
	urldate = {2024-11-25},
	date = {1989},
	langid = {english},
	file = {PDF:/home/wowaster/Zotero/storage/LI7MIGIF/Wadler - 1989 - Theorems for free!.pdf:application/pdf},
}

@inproceedings{marlowDeforestationHigherOrderFunctions1993,
	location = {London},
	title = {Deforestation for Higher-Order Functions},
	isbn = {978-1-4471-3215-8},
	doi = {10.1007/978-1-4471-3215-8_14},
	abstract = {Deforestation is an automatic transformation scheme for functional programs which attempts to remove unnecessary intermediate data structures. The algorithm presented here is a variant of the original, adapted for a higher order language. A detailed description of how this may be implemented in an optimising compiler is also given.},
	pages = {154--165},
	booktitle = {Functional Programming, Glasgow 1992},
	publisher = {Springer},
	author = {Marlow, Simon and Wadler, Philip},
	editor = {Launchbury, John and Sansom, Patrick},
	date = {1993},
	langid = {english},
}

@inproceedings{reindersHigherOrderPatterns2024,
	location = {Milan Italy},
	title = {Higher Order Patterns for Rewrite Rules},
	isbn = {979-8-4007-1102-2},
	url = {https://dl.acm.org/doi/10.1145/3677999.3678275},
	doi = {10.1145/3677999.3678275},
	abstract = {{GHC}’s rewrite rules enable programmers to write local program transformation rules for their own functions. The most notable use case are fusion optimizations, which merge multiple traversals of a data structure into one and avoids allocation of intermediate structures. However, {GHC}’s rewrite rules were too limited to express a rewrite rule that is necessary for proper fusion of the {concatMap} function in a variant of fusion called stream fusion. We introduce higher order patterns as a simple extension of {GHC}’s rewrite rules. Higher order patterns substantially broaden the expressiveness of rewrite rules that involve local variables. In particular, they enable the rewriting of {concatMap} such that it can be properly optimized. We implement a stream fusion framework to replace the existing fusion framework in {GHC} and evaluate it on {GHC}’s benchmark suite. Our stream fusion framework with higher order patterns shows an average speedup of 7\% compared to our stream fusion framework without it. However, our stream fusion framework is not yet able to match the performance of {GHC}’s existing fusion framework.},
	eventtitle = {Haskell '24: 17th {ACM} {SIGPLAN} International Haskell Symposium},
	pages = {14--26},
	booktitle = {Proceedings of the 17th {ACM} {SIGPLAN} International Haskell Symposium},
	publisher = {{ACM}},
	author = {Reinders, Jaro},
	urldate = {2024-12-11},
	date = {2024-08-29},
	langid = {english},
	file = {PDF:/home/wowaster/Zotero/storage/HMX5P3ZY/Reinders - 2024 - Higher Order Patterns for Rewrite Rules.pdf:application/pdf},
}

@inproceedings{couttsStreamFusionLists2007,
	location = {New York, {NY}, {USA}},
	title = {Stream fusion: from lists to streams to nothing at all},
	isbn = {978-1-59593-815-2},
	url = {https://doi.org/10.1145/1291151.1291199},
	doi = {10.1145/1291151.1291199},
	series = {{ICFP} '07},
	shorttitle = {Stream fusion},
	abstract = {This paper presents an automatic deforestation system, stream fusion, based on equational transformations, that fuses a wider range of functions than existing short-cut fusion systems. In particular, stream fusion is able to fuse zips, left folds and functions over nested lists, including list comprehensions. A distinguishing feature of the framework is its simplicity: by transforming list functions to expose their structure, intermediate values are eliminated by general purpose compiler optimisations.We have reimplemented the Haskell standard List library on top of our framework, providing stream fusion for Haskell lists. By allowing a wider range of functions to fuse, we see an increase in the number of occurrences of fusion in typical Haskell programs. We present benchmarks documenting time and space improvements.},
	pages = {315--326},
	booktitle = {Proceedings of the 12th {ACM} {SIGPLAN} international conference on Functional programming},
	publisher = {Association for Computing Machinery},
	author = {Coutts, Duncan and Leshchinskiy, Roman and Stewart, Don},
	urldate = {2024-12-11},
	date = {2007-10-01},
}

@inproceedings{farmerHERMITStreamFusing2014,
	location = {New York, {NY}, {USA}},
	title = {The {HERMIT} in the stream: fusing stream fusion's {concatMap}},
	isbn = {978-1-4503-2619-3},
	url = {https://doi.org/10.1145/2543728.2543736},
	doi = {10.1145/2543728.2543736},
	series = {{PEPM} '14},
	shorttitle = {The {HERMIT} in the stream},
	abstract = {Stream Fusion, a popular deforestation technique in the Haskell community, cannot fuse the {concatMap} combinator. This is a serious limitation, as {concatMap} represents computations on nested streams. The original implementation of Stream Fusion used the Glasgow Haskell Compiler's user-directed rewriting system. A transformation which allows the compiler to fuse many uses of {concatMap} has previously been proposed, but never implemented, because the host rewrite system was not expressive enough to implement the proposed transformation. In this paper, we develop a custom optimization plugin which implements the proposed {concatMap} transformation, and study the effectiveness of the transformation in practice. We also provide a new translation scheme for list comprehensions which enables them to be optimized. Within this framework, we extend the transformation to monadic streams. Code featuring uses of {concatMap} experiences significant speedup when compiled with this optimization. This allows Stream Fusion to outperform its rival, foldr/build, on many list computations, and enables performance-sensitive code to be expressed at a higher level of abstraction.},
	pages = {97--108},
	booktitle = {Proceedings of the {ACM} {SIGPLAN} 2014 Workshop on Partial Evaluation and Program Manipulation},
	publisher = {Association for Computing Machinery},
	author = {Farmer, Andrew and Hoener zu Siederdissen, Christian and Gill, Andy},
	urldate = {2024-12-19},
	date = {2014-01-11},
}
